package commands

import (
	"os"
	"path/filepath"
	"testing"
	"twist/internal/database"
	"twist/internal/scripting/types"
)

// TestDatabaseSetup provides a test database and mock VM for testing
type TestDatabaseSetup struct {
	DB           database.Database
	GameAdapter  GameAdapterInterface
	VM           types.VMInterface
	TempDBPath   string
}

// GameAdapterInterface provides interface for testing
type GameAdapterInterface interface {
	types.GameInterface
	SaveScriptVariable(name string, value *types.Value) error
	LoadScriptVariable(name string) (*types.Value, error)
}

// TestGameAdapter implements GameAdapterInterface for testing
type TestGameAdapter struct {
	db database.Database
}

func NewTestGameAdapter(db database.Database) *TestGameAdapter {
	return &TestGameAdapter{db: db}
}

func (g *TestGameAdapter) GetSector(index int) (types.SectorData, error) {
	return types.SectorData{Number: index}, nil
}

func (g *TestGameAdapter) SetSectorParameter(sector int, name, value string) error {
	return nil
}

func (g *TestGameAdapter) GetSectorParameter(sector int, name string) (string, error) {
	return "", nil
}

func (g *TestGameAdapter) GetCourse(from, to int) ([]int, error) {
	return []int{from, to}, nil
}

func (g *TestGameAdapter) GetDistance(from, to int) (int, error) {
	return 1, nil
}

func (g *TestGameAdapter) GetAllCourses(from int) (map[int][]int, error) {
	return make(map[int][]int), nil
}

func (g *TestGameAdapter) GetNearestWarps(sector int, count int) ([]int, error) {
	return []int{}, nil
}

func (g *TestGameAdapter) GetCurrentSector() int {
	return 1
}

func (g *TestGameAdapter) GetCurrentPrompt() string {
	return "Command [TL=00:00:00]:"
}

func (g *TestGameAdapter) SendCommand(cmd string) error {
	return nil
}

func (g *TestGameAdapter) GetLastOutput() string {
	return ""
}

func (g *TestGameAdapter) GetDatabase() interface{} {
	return g.db
}

func (g *TestGameAdapter) SaveScriptVariable(name string, value *types.Value) error {
	var dbValue interface{}
	switch value.Type {
	case types.StringType:
		dbValue = value.String
	case types.NumberType:
		dbValue = value.Number
	default:
		dbValue = value.String
	}
	return g.db.SaveScriptVariable(name, dbValue)
}

func (g *TestGameAdapter) LoadScriptVariable(name string) (*types.Value, error) {
	value, err := g.db.LoadScriptVariable(name)
	if err != nil {
		return nil, err
	}
	
	switch v := value.(type) {
	case string:
		return &types.Value{Type: types.StringType, String: v}, nil
	case float64:
		return &types.Value{Type: types.NumberType, Number: v}, nil
	default:
		return &types.Value{Type: types.StringType, String: ""}, nil
	}
}

// SetupTestDatabase creates a temporary SQLite database with real VM for testing
func SetupTestDatabase(t *testing.T) *TestDatabaseSetup {
	// Create temporary file for test database
	tempDir := t.TempDir()
	dbPath := filepath.Join(tempDir, "test.db")
	
	// Create database instance
	db := database.NewDatabase()
	err := db.CreateDatabase(dbPath)
	if err != nil {
		t.Fatalf("Failed to create test database: %v", err)
	}
	
	// Create game adapter with real database
	gameAdapter := NewTestGameAdapter(db)
	
	// Create mock VM with the game adapter
	testVM := &TestMockVM{
		variables:    make(map[string]*types.Value),
		gameAdapter:  gameAdapter,
	}
	
	return &TestDatabaseSetup{
		DB:          db,
		GameAdapter: gameAdapter,
		VM:          testVM,
		TempDBPath:  dbPath,
	}
}

// Cleanup closes the database and removes temporary files
func (setup *TestDatabaseSetup) Cleanup() {
	if setup.DB != nil {
		setup.DB.CloseDatabase()
	}
	// TempDir() automatically cleans up, but we can also explicitly remove
	if setup.TempDBPath != "" {
		os.Remove(setup.TempDBPath)
	}
}

// VerifyScriptVariable checks if a variable is stored in the database with expected value
func (setup *TestDatabaseSetup) VerifyScriptVariable(t *testing.T, name string, expectedValue interface{}) {
	value, err := setup.GameAdapter.LoadScriptVariable(name)
	if err != nil {
		t.Errorf("Failed to load script variable %s: %v", name, err)
		return
	}
	
	switch expectedValue := expectedValue.(type) {
	case string:
		if value.Type != types.StringType || value.String != expectedValue {
			t.Errorf("Variable %s: expected string %q, got %v %q", 
				name, expectedValue, value.Type, value.String)
		}
	case float64:
		if value.Type != types.NumberType || value.Number != expectedValue {
			t.Errorf("Variable %s: expected number %f, got %v %f", 
				name, expectedValue, value.Type, value.Number)
		}
	case int:
		expectedFloat := float64(expectedValue)
		if value.Type != types.NumberType || value.Number != expectedFloat {
			t.Errorf("Variable %s: expected number %f, got %v %f", 
				name, expectedFloat, value.Type, value.Number)
		}
	default:
		t.Errorf("Unsupported expected value type: %T", expectedValue)
	}
}

// SaveVariableToDatabase directly saves a variable to database for test setup
func (setup *TestDatabaseSetup) SaveVariableToDatabase(name string, value *types.Value) error {
	return setup.GameAdapter.SaveScriptVariable(name, value)
}

// TestMockVM implements VMInterface for testing
type TestMockVM struct {
	variables   map[string]*types.Value
	gameAdapter GameAdapterInterface
}

func (m *TestMockVM) GetVariable(name string) *types.Value {
	if val, exists := m.variables[name]; exists {
		return val
	}
	return &types.Value{Type: types.StringType, String: ""}
}

func (m *TestMockVM) SetVariable(name string, value *types.Value) {
	m.variables[name] = value
}

func (m *TestMockVM) GetGameInterface() types.GameInterface {
	return m.gameAdapter
}

func (m *TestMockVM) Echo(text string) error { return nil }
func (m *TestMockVM) ClientMessage(text string) error { return nil }
func (m *TestMockVM) Error(text string) error { 
	return &types.VMError{Message: text}
}
func (m *TestMockVM) Send(command string) error { return nil }
func (m *TestMockVM) WaitFor(pattern string) error { return nil }
func (m *TestMockVM) Pause() error { return nil }
func (m *TestMockVM) Halt() error { return nil }
func (m *TestMockVM) GetCurrentSector() int { return 1 }
func (m *TestMockVM) GetCurrentLine() string { return "" }
func (m *TestMockVM) Goto(label string) error { return nil }
func (m *TestMockVM) Gosub(label string) error { return nil }
func (m *TestMockVM) Return() error { return nil }
func (m *TestMockVM) GetInput(prompt string) (string, error) { return "", nil }
func (m *TestMockVM) GetCurrentScript() types.ScriptInterface { return nil }
func (m *TestMockVM) LoadAdditionalScript(filename string) (types.ScriptInterface, error) { return nil, nil }
func (m *TestMockVM) StopScript(scriptID string) error { return nil }
func (m *TestMockVM) GetScriptManager() interface{} { return nil }
func (m *TestMockVM) SetTrigger(trigger types.TriggerInterface) error { return nil }
func (m *TestMockVM) KillTrigger(triggerID string) error { return nil }
func (m *TestMockVM) GetActiveTriggersCount() int { return 0 }
func (m *TestMockVM) KillAllTriggers() {}
func (m *TestMockVM) ProcessInput(filter string) error { return nil }
func (m *TestMockVM) ProcessOutput(filter string) error { return nil }

// Test LOADVAR/SAVEVAR commands with database integration
func TestCmdLoadVarSaveVar_DatabaseIntegration(t *testing.T) {
	setup := SetupTestDatabase(t)
	defer setup.Cleanup()

	tests := []struct {
		name      string
		setupFunc func(t *testing.T, setup *TestDatabaseSetup)
		testFunc  func(t *testing.T, setup *TestDatabaseSetup)
	}{
		{
			name: "Save and load string variable",
			setupFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// Set a string variable in VM
				setup.VM.SetVariable("test_str", &types.Value{
					Type:   types.StringType,
					String: "Hello World",
				})
			},
			testFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// Save the variable
				saveParams := []*types.CommandParam{
					{Type: types.ParamVar, VarName: "test_str"},
				}
				err := cmdSaveVar(setup.VM, saveParams)
				if err != nil {
					t.Errorf("cmdSaveVar() error = %v", err)
					return
				}

				// Verify it was saved to database
				setup.VerifyScriptVariable(t, "test_str", "Hello World")

				// Clear VM variable
				setup.VM.SetVariable("test_str", &types.Value{Type: types.StringType, String: ""})

				// Load the variable back
				loadParams := []*types.CommandParam{
					{Type: types.ParamVar, VarName: "test_str"},
				}
				err = cmdLoadVar(setup.VM, loadParams)
				if err != nil {
					t.Errorf("cmdLoadVar() error = %v", err)
					return
				}

				// Verify it was loaded correctly
				loadedVar := setup.VM.GetVariable("test_str")
				if loadedVar.Type != types.StringType || loadedVar.String != "Hello World" {
					t.Errorf("Expected string 'Hello World', got %v '%s'", loadedVar.Type, loadedVar.String)
				}
			},
		},
		{
			name: "Save and load number variable",
			setupFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// Set a number variable in VM
				setup.VM.SetVariable("test_num", &types.Value{
					Type:   types.NumberType,
					Number: 42.5,
				})
			},
			testFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// Save the variable
				saveParams := []*types.CommandParam{
					{Type: types.ParamVar, VarName: "test_num"},
				}
				err := cmdSaveVar(setup.VM, saveParams)
				if err != nil {
					t.Errorf("cmdSaveVar() error = %v", err)
					return
				}

				// Verify it was saved to database
				setup.VerifyScriptVariable(t, "test_num", 42.5)

				// Clear VM variable
				setup.VM.SetVariable("test_num", &types.Value{Type: types.NumberType, Number: 0})

				// Load the variable back
				loadParams := []*types.CommandParam{
					{Type: types.ParamVar, VarName: "test_num"},
				}
				err = cmdLoadVar(setup.VM, loadParams)
				if err != nil {
					t.Errorf("cmdLoadVar() error = %v", err)
					return
				}

				// Verify it was loaded correctly
				loadedVar := setup.VM.GetVariable("test_num")
				if loadedVar.Type != types.NumberType || loadedVar.Number != 42.5 {
					t.Errorf("Expected number 42.5, got %v %f", loadedVar.Type, loadedVar.Number)
				}
			},
		},
		{
			name: "Load non-existent variable returns empty string",
			setupFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// No setup needed - variable doesn't exist
			},
			testFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// Try to load non-existent variable
				loadParams := []*types.CommandParam{
					{Type: types.ParamVar, VarName: "nonexistent"},
				}
				err := cmdLoadVar(setup.VM, loadParams)
				if err != nil {
					t.Errorf("cmdLoadVar() error = %v", err)
					return
				}

				// Should set variable to empty string
				loadedVar := setup.VM.GetVariable("nonexistent")
				if loadedVar.Type != types.StringType || loadedVar.String != "" {
					t.Errorf("Expected empty string, got %v '%s'", loadedVar.Type, loadedVar.String)
				}
			},
		},
		{
			name: "Save overwrites existing variable",
			setupFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// Pre-populate database with a variable
				err := setup.SaveVariableToDatabase("overwrite_test", &types.Value{
					Type:   types.StringType,
					String: "original",
				})
				if err != nil {
					t.Fatalf("Failed to pre-populate database: %v", err)
				}

				// Set new value in VM
				setup.VM.SetVariable("overwrite_test", &types.Value{
					Type:   types.StringType,
					String: "updated",
				})
			},
			testFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// Save the updated variable
				saveParams := []*types.CommandParam{
					{Type: types.ParamVar, VarName: "overwrite_test"},
				}
				err := cmdSaveVar(setup.VM, saveParams)
				if err != nil {
					t.Errorf("cmdSaveVar() error = %v", err)
					return
				}

				// Verify it was updated in database
				setup.VerifyScriptVariable(t, "overwrite_test", "updated")
			},
		},
		{
			name: "Save empty string variable",
			setupFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// Set an empty string variable in VM
				setup.VM.SetVariable("empty_str", &types.Value{
					Type:   types.StringType,
					String: "",
				})
			},
			testFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// Save the variable
				saveParams := []*types.CommandParam{
					{Type: types.ParamVar, VarName: "empty_str"},
				}
				err := cmdSaveVar(setup.VM, saveParams)
				if err != nil {
					t.Errorf("cmdSaveVar() error = %v", err)
					return
				}

				// Verify it was saved to database
				setup.VerifyScriptVariable(t, "empty_str", "")

				// Clear VM variable with non-empty value
				setup.VM.SetVariable("empty_str", &types.Value{Type: types.StringType, String: "not empty"})

				// Load the variable back
				loadParams := []*types.CommandParam{
					{Type: types.ParamVar, VarName: "empty_str"},
				}
				err = cmdLoadVar(setup.VM, loadParams)
				if err != nil {
					t.Errorf("cmdLoadVar() error = %v", err)
					return
				}

				// Verify it was loaded as empty string
				loadedVar := setup.VM.GetVariable("empty_str")
				if loadedVar.Type != types.StringType || loadedVar.String != "" {
					t.Errorf("Expected empty string, got %v '%s'", loadedVar.Type, loadedVar.String)
				}
			},
		},
		{
			name: "Save zero number variable",
			setupFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// Set a zero number variable in VM
				setup.VM.SetVariable("zero_num", &types.Value{
					Type:   types.NumberType,
					Number: 0,
				})
			},
			testFunc: func(t *testing.T, setup *TestDatabaseSetup) {
				// Save the variable
				saveParams := []*types.CommandParam{
					{Type: types.ParamVar, VarName: "zero_num"},
				}
				err := cmdSaveVar(setup.VM, saveParams)
				if err != nil {
					t.Errorf("cmdSaveVar() error = %v", err)
					return
				}

				// Verify it was saved to database
				setup.VerifyScriptVariable(t, "zero_num", 0.0)

				// Clear VM variable with non-zero value
				setup.VM.SetVariable("zero_num", &types.Value{Type: types.NumberType, Number: 999})

				// Load the variable back
				loadParams := []*types.CommandParam{
					{Type: types.ParamVar, VarName: "zero_num"},
				}
				err = cmdLoadVar(setup.VM, loadParams)
				if err != nil {
					t.Errorf("cmdLoadVar() error = %v", err)
					return
				}

				// Verify it was loaded as zero
				loadedVar := setup.VM.GetVariable("zero_num")
				if loadedVar.Type != types.NumberType || loadedVar.Number != 0 {
					t.Errorf("Expected number 0, got %v %f", loadedVar.Type, loadedVar.Number)
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.setupFunc != nil {
				tt.setupFunc(t, setup)
			}
			tt.testFunc(t, setup)
		})
	}
}

// Test multiple variables saved and loaded in sequence
func TestCmdLoadVarSaveVar_MultipleVariables(t *testing.T) {
	setup := SetupTestDatabase(t)
	defer setup.Cleanup()

	// Set up multiple variables
	variables := map[string]*types.Value{
		"var1": {Type: types.StringType, String: "first"},
		"var2": {Type: types.NumberType, Number: 123},
		"var3": {Type: types.StringType, String: "third"},
		"var4": {Type: types.NumberType, Number: 456.789},
	}

	// Set variables in VM and save them
	for name, value := range variables {
		setup.VM.SetVariable(name, value)
		
		saveParams := []*types.CommandParam{
			{Type: types.ParamVar, VarName: name},
		}
		err := cmdSaveVar(setup.VM, saveParams)
		if err != nil {
			t.Errorf("cmdSaveVar(%s) error = %v", name, err)
			continue
		}
	}

	// Clear all VM variables
	for name := range variables {
		setup.VM.SetVariable(name, &types.Value{Type: types.StringType, String: ""})
	}

	// Load all variables back
	for name, expectedValue := range variables {
		loadParams := []*types.CommandParam{
			{Type: types.ParamVar, VarName: name},
		}
		err := cmdLoadVar(setup.VM, loadParams)
		if err != nil {
			t.Errorf("cmdLoadVar(%s) error = %v", name, err)
			continue
		}

		// Verify loaded value
		loadedVar := setup.VM.GetVariable(name)
		if expectedValue.Type == types.StringType {
			if loadedVar.Type != types.StringType || loadedVar.String != expectedValue.String {
				t.Errorf("Variable %s: expected string '%s', got %v '%s'", 
					name, expectedValue.String, loadedVar.Type, loadedVar.String)
			}
		} else if expectedValue.Type == types.NumberType {
			if loadedVar.Type != types.NumberType || loadedVar.Number != expectedValue.Number {
				t.Errorf("Variable %s: expected number %f, got %v %f", 
					name, expectedValue.Number, loadedVar.Type, loadedVar.Number)
			}
		}
	}
}